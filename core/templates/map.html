{% extends 'base.html' %}
{% block title %}Canlı Harita - Looopone{% endblock %}

{% block extra_css %}
<style>
    #map { height: 90vh; width: 100%; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); background-color: #f8f9fa; }
    .info-box { color: #333; padding: 5px; font-family: sans-serif; min-width: 150px; }
    .status-bar-bg { background: #eee; height: 10px; border-radius: 5px; width: 100%; margin: 5px 0; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid p-3">
    <div class="card border-0 shadow-sm">
        <div class="card-body p-0">
            <div id="map"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAlqqY_7xi8nLbXt-COj73W7KUwEpBr5Dg&callback=initMap" async defer></script>

<script>
    let map;
    let markers = [];
    let balcovaPolygonOverlays = [];
    let balcovaBoundaryGeojson = null;
    let directionsService;
    let directionsRenderer;
    const BALCOVA_FALLBACK = { latMin: 38.370, latMax: 38.420, lngMin: 27.020, lngMax: 27.080 };

    async function fetchBalcovaBoundary() {
        const url = 'https://nominatim.openstreetmap.org/search?q=Bal%C3%A7ova,+%C4%B0zmir,+Turkey&format=json&polygon_geojson=1&limit=1';
        try {
            const response = await fetch(url, { headers: { 'User-Agent': 'LoooponeApp/1.0' } });
            const data = await response.json();
            if (data.length > 0 && data[0].geojson) return data[0].geojson;
        } catch (e) { console.warn('Balçova sınır API hatası, fallback kullanılıyor:', e); }
        return null;
    }

    function isPointInPolygon(lat, lng, ring) {
        const la = parseFloat(lat), ln = parseFloat(lng);
        let inside = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            const xi = ring[i][1], yi = ring[i][0];
            const xj = ring[j][1], yj = ring[j][0];
            const intersect = ((yi > ln) !== (yj > ln)) && (la < (xj - xi) * (ln - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function isInBalcovaBounds(lat, lng) {
        const la = parseFloat(lat), ln = parseFloat(lng);
        if (isNaN(la) || isNaN(ln)) return false;
        if (balcovaBoundaryGeojson) {
            const g = balcovaBoundaryGeojson;
            if (g.type === 'Polygon' && g.coordinates && g.coordinates[0])
                return isPointInPolygon(la, ln, g.coordinates[0]);
            if (g.type === 'MultiPolygon' && g.coordinates)
                return g.coordinates.some(ringList => ringList[0] && isPointInPolygon(la, ln, ringList[0]));
        }
        return la >= BALCOVA_FALLBACK.latMin && la <= BALCOVA_FALLBACK.latMax && ln >= BALCOVA_FALLBACK.lngMin && ln <= BALCOVA_FALLBACK.lngMax;
    }

    function ringToGooglePath(ring) {
        return ring.map(c => ({ lat: c[1], lng: c[0] }));
    }

    function drawBalcovaBoundary(geojson) {
        balcovaPolygonOverlays.forEach(p => p.setMap(null));
        balcovaPolygonOverlays = [];
        const strokeColor = '#059669';
        const fillColor = '#0080ff';
        const style = {
            strokeColor, strokeOpacity: 0.8, strokeWeight: 2,
            fillColor, fillOpacity: 0.1
        };
        if (geojson && geojson.type === 'Polygon' && geojson.coordinates && geojson.coordinates[0]) {
            const poly = new google.maps.Polygon({
                paths: ringToGooglePath(geojson.coordinates[0]),
                ...style,
                map: map
            });
            balcovaPolygonOverlays.push(poly);
        } else if (geojson && geojson.type === 'MultiPolygon' && geojson.coordinates) {
            geojson.coordinates.forEach(ringList => {
                if (ringList[0]) {
                    const poly = new google.maps.Polygon({
                        paths: ringToGooglePath(ringList[0]),
                        ...style,
                        map: map
                    });
                    balcovaPolygonOverlays.push(poly);
                }
            });
        } else {
            const fallbackPath = [
                { lat: BALCOVA_FALLBACK.latMin, lng: BALCOVA_FALLBACK.lngMin },
                { lat: BALCOVA_FALLBACK.latMax, lng: BALCOVA_FALLBACK.lngMin },
                { lat: BALCOVA_FALLBACK.latMax, lng: BALCOVA_FALLBACK.lngMax },
                { lat: BALCOVA_FALLBACK.latMin, lng: BALCOVA_FALLBACK.lngMax }
            ];
            balcovaPolygonOverlays.push(new google.maps.Polygon({ paths: fallbackPath, ...style, map: map }));
        }
    }

    function initMap() {
        map = new google.maps.Map(document.getElementById("map"), {
            center: { lat: 38.3894, lng: 27.0461 },
            zoom: 13
        });

        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            suppressMarkers: true,
            polylineOptions: { strokeColor: "#2563eb", strokeWeight: 5 }
        });
        directionsRenderer.setMap(map);

        (async function loadBalcovaAndData() {
            balcovaBoundaryGeojson = await fetchBalcovaBoundary();
            drawBalcovaBoundary(balcovaBoundaryGeojson);
            addMarkerFromQueryParams();
            updateData();
            setInterval(updateData, 30000);

            map.addListener('click', function(ev) {
                const lat = ev.latLng.lat(), lng = ev.latLng.lng();
                const inside = isInBalcovaBounds(lat, lng);
                const marker = new google.maps.Marker({
                    position: { lat: lat, lng: lng },
                    map: map,
                    icon: inside
                        ? { path: google.maps.SymbolPath.CIRCLE, scale: 14, fillColor: '#10b981', fillOpacity: 1, strokeColor: '#059669', strokeWeight: 2 }
                        : { path: google.maps.SymbolPath.CIRCLE, scale: 14, fillColor: '#9ca3af', fillOpacity: 1, strokeColor: '#6b7280', strokeWeight: 2 }
                });
                if (inside) {
                    const info = new google.maps.InfoWindow({
                        content: '<strong>Bu noktada sorun bildir</strong><br><a href="/report-issue/?lat=' + encodeURIComponent(lat) + '&lng=' + encodeURIComponent(lng) + '">Sorun bildir formuna git</a>'
                    });
                    marker.addListener('click', () => info.open(map, marker));
                    info.open(map, marker);
                    markers.push(marker);
                } else {
                    const warn = new google.maps.InfoWindow({
                        content: '⚠️ Sadece Balçova ilçesi sınırları içinden sorun bildirebilirsiniz.'
                    });
                    warn.open(map, marker);
                    setTimeout(function() { marker.setMap(null); warn.close(); }, 3000);
                }
            });
        })();
    }

    function addMarkerFromQueryParams() {
        const params = new URLSearchParams(window.location.search);
        const lat = parseFloat(params.get('new_lat'));
        const lng = parseFloat(params.get('new_lng'));
        const type = (params.get('new_type') || '').toUpperCase();
        const desc = params.get('new_desc') || 'Yeni bildirim';
        if (isNaN(lat) || isNaN(lng) || !map) return;
        const icons = {
            'HALK_PAZARI': 'http://maps.google.com/mapfiles/kml/shapes/shopping_cart.png',
            'MARKET_SEVKIYAT': 'http://maps.google.com/mapfiles/kml/shapes/truck.png',
            'TRAFIK_ENGEL': 'http://maps.google.com/mapfiles/kml/shapes/parking_lot_maps.png',
            'MOLOZ': 'http://maps.google.com/mapfiles/kml/shapes/caution.png',
            'ROAD': 'http://maps.google.com/mapfiles/kml/shapes/info_circle.png'
        };
        const valid = isInBalcovaBounds(lat, lng);
        const marker = new google.maps.Marker({
            position: { lat: lat, lng: lng },
            map: map,
            icon: valid
                ? { url: icons[type] || 'http://maps.google.com/mapfiles/kml/shapes/info_circle.png', scaledSize: new google.maps.Size(40, 40) }
                : { path: google.maps.SymbolPath.CIRCLE, scale: 12, fillColor: '#9ca3af', fillOpacity: 1, strokeColor: '#6b7280', strokeWeight: 2 },
            title: valid ? desc : 'Geçersiz konum (Balçova dışı)'
        });
        const infoWindow = new google.maps.InfoWindow({
            content: valid
                ? '<strong>Yeni bildirim</strong><br>' + (type ? type.replace(/_/g, ' ') : '') + '<br>' + desc
                : '<strong>Geçersiz konum</strong><br>Sadece Balçova ilçesi sınırları içinden sorun bildirilebilir.'
        });
        marker.addListener('click', () => infoWindow.open(map, marker));
        markers.push(marker);
        map.panTo({ lat: lat, lng: lng });
        if (history.replaceState) history.replaceState({}, document.title, window.location.pathname);
    }

function updateData() {
    fetch('/api/containers/', { cache: "no-store" })
        .then(response => response.json())
        .then(data => {
            // 1. Önce haritadaki eski marker ve daireleri temizle
            markers.forEach(m => m.setMap(null));
            markers = [];

            // 2. İkon tanımlarını ve zaman kontrollerini yap (Döngüden ÖNCE gelmeli)
            const icons = {
                'HALK_PAZARI': 'http://maps.google.com/mapfiles/kml/shapes/shopping_cart.png', 
                'MARKET_SEVKIYAT': 'http://maps.google.com/mapfiles/kml/shapes/truck.png', 
                'TRAFIK_ENGEL': 'http://maps.google.com/mapfiles/kml/shapes/parking_lot_maps.png',
                'MOLOZ': 'http://maps.google.com/mapfiles/kml/shapes/caution.png', 
                'ROAD': 'http://maps.google.com/mapfiles/kml/shapes/info_circle.png'
            };

            const currentHour = new Date().getHours();
            const isDeliveryHour = (currentHour >= 8 && currentHour <= 11);

            // 3. Veri Döngüsü (Her bir konteyner/bildirim için işlem yap)
            data.forEach(container => {
                const lat = parseFloat(container.lat);
                const lng = parseFloat(container.lng);
                
                // Koordinat yoksa bu kaydı atla
                if (isNaN(lat) || isNaN(lng)) return;

                // Veritabanından gelen 'tip' bilgisini yakala (Büyük harfe çevirerek garantile)
                const type = (container.type || container.container_type || container.point_type || "").toUpperCase();
                let iconUrl = icons[type] || null;

                if (iconUrl) {
                    // ÖZEL BİLDİRİMLER (Pazar, Market vb.) İÇİN MARKER OLUŞTUR
                    const marker = new google.maps.Marker({
                        position: { lat: lat, lng: lng },
                        map: map,
                        icon: { url: iconUrl, scaledSize: new google.maps.Size(35, 35) },
                        title: container.address || type
                    });

                    // Zıplama Efektleri
                    if (type === 'MARKET_SEVKIYAT' && isDeliveryHour) {
                        marker.setAnimation(google.maps.Animation.BOUNCE);
                    }
                    if (type === 'HALK_PAZARI' && currentHour >= 17) {
                        marker.setAnimation(google.maps.Animation.BOUNCE);
                    }

                    // Bilgi Penceresi
                    const infoWindow = new google.maps.InfoWindow({
                        content: `<strong>${type}</strong><br>${container.address || 'Adres bilgisi yok'}`
                    });
                    marker.addListener("click", () => infoWindow.open(map, marker));
                    
                    markers.push(marker);

                } else {
                    // NORMAL ÇÖP KONTEYNERLERİ İÇİN DAİRE OLUŞTUR
                    let color = container.fill >= 80 ? "#ef4444" : (container.fill >= 50 ? "#f59e0b" : "#10b981");
                    const circle = new google.maps.Circle({
                        strokeColor: color,
                        strokeOpacity: 0.8,
                        strokeWeight: 2,
                        fillColor: color,
                        fillOpacity: 0.35,
                        map: map,
                        center: { lat: lat, lng: lng },
                        radius: 30
                    });

                    const infoWindow = new google.maps.InfoWindow({
                        content: `<strong>Konteyner #${container.id}</strong><br>Doluluk: %${container.fill}`
                    });
                    circle.addListener("click", () => {
                        infoWindow.setPosition(circle.getCenter());
                        infoWindow.open(map);
                    });

                    markers.push(circle);
                }
            });

            // 4. Rota Çizimini Güncelle
            drawRoute(data);
        })
        .catch(error => console.error("Veri çekme hatası:", error));
}


    function drawRoute(data) {
        // Şimdilik testi kolaylaştırmak için sınırı 10'a çektim
        const waypoints = data
            .filter(c => c.fill >= 0) 
            .map(c => ({
                location: new google.maps.LatLng(parseFloat(c.lat), parseFloat(c.lng)),
                stopover: true
            }));

        if (waypoints.length < 2) {
            directionsRenderer.setDirections({routes: []});
            return;
        }

        const origin = waypoints.shift().location;
        const destination = waypoints.pop().location;

        directionsService.route({
            origin: origin,
            destination: destination,
            waypoints: waypoints,
            optimizeWaypoints: true,
            travelMode: google.maps.TravelMode.DRIVING,
        }, (result, status) => {
            if (status === google.maps.DirectionsStatus.OK) {
                directionsRenderer.setDirections(result);
            } else {
                console.error("Rota çizilemedi: " + status);
            }
        });
    }
</script>
{% endblock %}